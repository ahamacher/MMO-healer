/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/errors.js":
/*!***********************!*\
  !*** ./src/errors.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("class GameErrors {\n  constructor(ctx, errorCode) {\n    this.ctx = ctx;\n    this.errorCode = errorCode;\n  }\n\n  draw() {\n    if (this.errorCode !== 0) {\n      this.ctx.fillStyle = '#FF0000';\n      this.ctx.font = \"bold 18px Arial\";\n      this.ctx.textAlign = \"center\";\n      this.ctx.fillText(GAME_ERROR[this.errorCode], 282, 375);\n    };\n  };\n};\n\nGAME_ERROR = {\n  0: null,\n  1: \"Not ready to use that yet\",\n  2: \"Not enough mana\",\n  3: \"Invalid Target\"\n};\n\nmodule.exports = GameErrors;\n\n\n//# sourceURL=webpack:///./src/errors.js?");

/***/ }),

/***/ "./src/game.js":
/*!*********************!*\
  !*** ./src/game.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Tank = __webpack_require__(/*! ./units/tank.js */ \"./src/units/tank.js\");\nconst Healer = __webpack_require__(/*! ./units/healer.js */ \"./src/units/healer.js\");\nconst Dps = __webpack_require__(/*! ./units/dps.js */ \"./src/units/dps.js\");\nconst Boss = __webpack_require__(/*! ./units/boss.js */ \"./src/units/boss.js\");\nconst Spells = __webpack_require__(/*! ./spells.js */ \"./src/spells.js\");\nconst BossSpells = __webpack_require__(/*! ./units/boss_spells.js */ \"./src/units/boss_spells.js\");\nconst GameErrors = __webpack_require__(/*! ./errors.js */ \"./src/errors.js\");\n\nclass Game {\n  constructor(options){\n    // teamcomp array goes {tanks: X, healer: Y, dps: Z}\n    this.comp = options.comp;\n    this.bossScript = options.bossScript;\n    this.party = [];\n    this.dead = options.dead;\n    this.activeGCD = false;\n    this.gcdTime = 1800;\n    this.gcdRemaining = 1800;\n    this.isCasting = false;\n    this.castTimeInitial = 0;\n    this.castTime = 0;\n    this.spellText = \"\";\n    this.mp = 1000;\n    this.bg = options.bg;\n    this.spellIcons = options.spellIcons;\n    this.statusIcon = options.statusIcon;\n    this.overheal = 0;\n    this.healed = 0;\n    this.deathCount = 0;\n    this.gameOver = false;\n    this.gameOverBad = false;\n    this.currentLevel = options.level;\n    this.errorCode = 0;\n    this.errorDisplay = null;\n    this.mpRegenTimer = 75;\n    this.hovered = null;\n\n    this.impactCD = 0;\n    this.impactMaxCD = 20000;\n\n    // boss spell counters for hp % timers\n    this.nextBossSpell = null;\n\n    // probably not needed\n    this.ctx = options.ctx;\n    this.canvas = options.canvas;\n\n    // creating units\n    this.addFriendlyNpc(options.ctx, options.canvas);\n    this.addBoss(options.ctx, options.canvas, options.bossSrc);\n    this.addPlayerSpells();\n    this.addClickableSpells(options.ctx);\n    this.addSpellHover(options.ctx);\n    this.makeBossSpells();\n\n  }\n\n  findSelected(){\n    const selected = this.party.find(member => member.selected === true);\n    \n    this.party.forEach(member => {\n      if (member !== selected){\n        member.selected = false;\n      }\n    });\n    if (selected) {\n      return selected;\n    } else {\n      return false;\n    }\n  }\n\n  clearSelected(){\n    this.party.forEach(member => {\n      member.selected = false;\n    });\n  }\n\n  deadPlayerCheck(){\n    let player;\n    this.party.forEach(member => {\n      if (member.attackValue === 0) {\n        player = member;\n      }\n    });\n    if (player.currentHp === 0){\n      this.gameOverBad = true;\n    }\n  }\n\n  addFriendlyNpc(ctx, canvas){\n    if (this.comp.tank + this.comp.healer + this.comp.dps > 20){\n      return \"error too many partymembers\";\n    }\n    let pos = 0;\n    let i = 0;\n    let j = 0;\n    let k = 0;\n\n    while (i < this.comp.tank){\n      const npcIcon = this.getRandomIcon(\"tank\");\n      this.party.push(new Tank({\n        pos: Game.NPC_POS[pos], \n        ctx, \n        canvas, \n        game: this, \n        speed: Game.SPEED, \n        statusIcon: this.statusIcon, \n        npcIcon: npcIcon }));\n      // this.addNpcListener(pos);\n      pos = pos + 1;\n      i = i + 1;\n    }\n    while (j < this.comp.healer){\n      const npcIcon = this.getRandomIcon(\"healer\");\n      this.party.push(new Healer({ \n        pos: Game.NPC_POS[pos], \n        ctx, \n        canvas, \n        game: this, \n        speed: Game.SPEED, \n        statusIcon: this.statusIcon,\n        npcIcon: npcIcon }));\n      // this.addNpcListener(pos);\n      pos = pos + 1;\n      j = j + 1;\n    }\n    while (k < this.comp.dps){\n      const npcIcon = this.getRandomIcon(\"dps\");\n      this.party.push(new Dps({ \n        pos: Game.NPC_POS[pos], \n        ctx, \n        canvas, \n        game: this, \n        speed: Game.SPEED, \n        statusIcon: this.statusIcon,\n        npcIcon: npcIcon }));\n      // this.addNpcListener(pos);\n      pos = pos + 1;\n      k = k + 1;\n    }\n  }\n\n  getRandomIcon(unit) {\n    const tankNum = 2;\n    const dpsNum = 5;\n    const healerNum = 2;\n\n    let numUnit;\n    let imgSrc = '../assets/sprites/';\n\n    switch (unit) {\n      case \"tank\":\n        numUnit = this.getRandNum(tankNum);\n        imgSrc += \"tank\" + numUnit + \".png\";\n        const tankIcon = new Image(1,1);\n        tankIcon.src = imgSrc;\n        return tankIcon;\n      case \"dps\":\n        numUnit = this.getRandNum(dpsNum);\n        imgSrc += \"dps\" + numUnit + \".png\";\n        const dpsIcon = new Image(1,1);\n        dpsIcon.src = imgSrc;\n        return dpsIcon;\n      case \"healer\":\n        numUnit = this.getRandNum(healerNum);\n        imgSrc += \"healer\" + numUnit + \".png\";\n        const healerIcon = new Image(1,1);\n        healerIcon.src = imgSrc;\n        return healerIcon;\n      default:\n        break;\n    }\n  }\n\n  getRandNum(max){\n    return Math.floor(Math.random() * (max + 1));\n  }\n\n  addBoss(ctx, canvas, bossSrc) {\n    let maxHp;\n    switch (this.currentLevel) {\n      case \"level1\":\n        maxHp = 2000;\n        break;\n      case \"level2\":\n        maxHp = 6000;\n        break;\n      default:\n        break;\n    }\n    this.boss = new Boss({ pos: [633,104], ctx, canvas, game: this, bossSrc, maxHp });\n  }\n\n  playerCastBar(ctx) {\n    let yPos = 461;\n    let xPos = 47 + 163 + 163;\n    let width = 143;\n    let height = 21;\n    let textPosX = xPos + width / 2;\n    let textPosY = yPos + 17;\n\n    if (this.isCasting){\n      let barLength = ((this.castTime / this.castTimeInitial) * width);\n      if (this.castTime < Game.SPEED) {\n        barLength = 0;\n      }\n\n      ctx.fillStyle = '#000000';\n      ctx.roundRect(xPos, yPos, width, height, {lowerLeft: 10, upperLeft: 10, upperRight: 10, lowerRight: 10}, true, false);\n\n      // handles low values of length for the cast bar due to the rounded rectangle\n      ctx.fillStyle = '#9900cc';\n      if (barLength < 3 && barLength >= 0) {\n        ctx.roundRect(xPos, yPos, barLength, height, {lowerLeft: 10, upperLeft: 10, upperRight: 1, lowerRight: 1}, true, false);\n      } else if (barLength < 5 && barLength >= 3){\n        ctx.roundRect(xPos, yPos, barLength, height, {lowerLeft: 10, upperLeft: 10, upperRight: 4, lowerRight: 4}, true, false);\n      } else if (barLength < 7 && barLength >= 5){\n        ctx.roundRect(xPos, yPos, barLength, height, {lowerLeft: 10, upperLeft: 10, upperRight: 7, lowerRight: 7}, true, false);\n      } else if (barLength < 11 && barLength >= 7) {\n        ctx.roundRect(xPos, yPos, barLength, height, {lowerLeft: 10, upperLeft: 10, upperRight: 9, lowerRight: 9}, true, false);\n      } else {\n        ctx.roundRect(xPos, yPos, barLength, height, {lowerLeft: 10, upperLeft: 10, upperRight: 10, lowerRight: 10}, true, false);\n      }\n\n      ctx.fillStyle = '#FFFFFF';\n      ctx.font = \"16px Arial\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(this.spellText, textPosX, textPosY);\n\n      ctx.strokeStyle = '#FFFFFF';\n      ctx.lineWidth = 2;\n      ctx.roundRect(xPos, yPos, width, height, {lowerLeft: 10, upperLeft: 10, upperRight: 10, lowerRight: 10}, false, true);\n\n      this.castTime += Game.SPEED;\n    }\n    if (this.castTime >= this.castTimeInitial){\n      this.castTime = 0;\n      this.isCasting = false;\n      this.castTimeInitial = 0;\n      this.spellText = \"\";\n    }\n  }\n\n  manaBar(ctx){\n    // manabar backing\n    let yPos = 461;\n    let xPos = 47 + 163;\n    let width = 143;\n    let height = 21;\n    let textPosX = xPos + width / 2;\n    let textPosY = yPos + 17;\n\n    //background\n    ctx.fillStyle = '#000000';\n    ctx.roundRect(xPos, yPos, width, height, {lowerLeft: 10, upperLeft: 10, upperRight: 10, lowerRight: 10}, true, false);\n\n    const currentMp = ((this.mp / 1000) * width);\n\n    // this handles low mp values to not create a buggy view of trying to have a larger than possible radius\n    if (this.mp < 100 && this.mp > 70) {\n      ctx.fillStyle = '#0066cc';\n      ctx.roundRect(xPos, yPos, currentMp, height, {lowerLeft: 10, upperLeft: 10, upperRight: 7, lowerRight: 7}, true, false);\n    } else if (this.mp <= 70 && this.mp > 40) {\n      ctx.fillStyle = '#0066cc';\n      ctx.roundRect(xPos, yPos, currentMp, height, {lowerLeft: 10, upperLeft: 10, upperRight: 4, lowerRight: 4}, true, false);\n    } else if (this.mp <= 40 && this.mp > 25) {\n      ctx.fillStyle = '#0066cc';\n      ctx.roundRect(xPos, yPos, currentMp, height, {lowerLeft: 10, upperLeft: 10, upperRight: 1, lowerRight: 1}, true, false);\n    } else if (this.mp <= 25 && this.mp > 10) {\n      ctx.fillStyle = '#0066cc';\n      ctx.roundRect(xPos, yPos, 5, height, {lowerLeft: 10, upperLeft: 10, upperRight: 1, lowerRight: 1}, true, false);\n    } else if (this.mp < 10) {\n      ctx.fillStyle = '#000000';\n      ctx.roundRect(xPos, yPos, 0, height, {lowerLeft: 10, upperLeft: 10, upperRight: 10, lowerRight: 10}, false, false);\n    } else {\n      ctx.fillStyle = '#0066cc';\n      ctx.roundRect(xPos, yPos, currentMp, height, {lowerLeft: 10, upperLeft: 10, upperRight: 10, lowerRight: 10}, true, false);\n    }\n\n    //manabar outline\n    ctx.strokeStyle = '#FFFFFF';\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.roundRect(xPos, yPos, width, height, {lowerLeft: 10, upperLeft: 10, upperRight: 10, lowerRight: 10}, false, true);\n\n    //label text\n    ctx.fillStyle = 'gold';\n    ctx.font = '16px sans-serif';\n    ctx.textAlign = \"start\";\n    ctx.fillText(\"Mana\", xPos + 11, yPos - 5);\n\n    // mana bar inner text showing current mana\n    ctx.fillStyle = '#FFFFFF';\n    ctx.font = '16px sans-serif';\n    ctx.textAlign = \"center\";\n    ctx.fillText(`${this.mp}`, textPosX , textPosY);\n  }\n\n  healthBar(ctx) {\n    // healthbar positions\n    let yPos = 461;\n    let xPos = 47;\n    let width = 143;\n    let height = 21;\n    let textPosX = xPos + width / 2;\n    let textPosY = yPos + 17;\n\n    const healer = this.findHealer();\n\n    // background\n    ctx.fillStyle = '#000000';\n    ctx.roundRect(xPos, yPos, width, height, {lowerLeft: 10, upperLeft: 10, upperRight: 10, lowerRight: 10}, true, false);\n\n    // this handles the current hp progressbar and allows for it to change shape at low hp values\n    let currentHpNumber = healer.currentHp;\n    const currentHpWidth = ((healer.currentHp / 100) * width);\n\n    if (currentHpNumber < 100 && currentHpNumber > 70) {\n      ctx.fillStyle = '#009933';\n      ctx.roundRect(xPos, yPos, currentHpWidth, height, {lowerLeft: 10, upperLeft: 10, upperRight: 7, lowerRight: 7}, true, false);\n    } else if (currentHpNumber <= 70 && currentHpNumber > 40) {\n      ctx.fillStyle = '#009933';\n      ctx.roundRect(xPos, yPos, currentHpWidth, height, {lowerLeft: 10, upperLeft: 10, upperRight: 4, lowerRight: 4}, true, false);\n    } else if (currentHpNumber <= 40 && currentHpNumber > 25) {\n      ctx.fillStyle = '#009933';\n      ctx.roundRect(xPos, yPos, currentHpWidth, height, {lowerLeft: 10, upperLeft: 10, upperRight: 1, lowerRight: 1}, true, false);\n    } else if (currentHpNumber <= 25 && currentHpNumber > 10) {\n      ctx.fillStyle = '#009933';\n      ctx.roundRect(xPos, yPos, 5, height, {lowerLeft: 10, upperLeft: 10, upperRight: 1, lowerRight: 1}, true, false);\n    } else if (currentHpNumber < 10) {\n      ctx.fillStyle = '#000000';\n      ctx.roundRect(xPos, yPos, 0, height, {lowerLeft: 10, upperLeft: 10, upperRight: 10, lowerRight: 10}, false, false);\n    } else {\n      ctx.fillStyle = '#009933';\n      ctx.roundRect(xPos, yPos, currentHpWidth, height, {lowerLeft: 10, upperLeft: 10, upperRight: 10, lowerRight: 10}, true, false);\n    }\n\n    //healthbar outline\n    ctx.strokeStyle = '#FFFFFF';\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.roundRect(xPos, yPos, width, height, {lowerLeft: 10, upperLeft: 10, upperRight: 10, lowerRight: 10}, false, true);\n\n    //label text\n    ctx.fillStyle = 'gold';\n    ctx.font = '16px sans-serif';\n    ctx.textAlign = \"start\";\n    ctx.fillText(\"Health\", xPos + 11, yPos - 5);\n\n    // displays current HP values\n    ctx.fillStyle = '#FFFFFF';\n    ctx.font = '16px sans-serif';\n    ctx.textAlign = \"center\";\n    ctx.fillText(`${Math.floor(currentHpNumber)}%`, textPosX , textPosY);\n  }\n\n  findHealer() {\n    //this will return the party's healer object\n    for (let i = 0; i < this.party.length; i++) {\n      const element = this.party[i];\n      if (element instanceof Healer) {\n        return element;\n      }\n    }\n  }\n\n  addPlayerSpells(){\n    document.addEventListener('keydown', (e) => {\n      switch (e.which){\n        case 49:\n          this.castSpell(\"cure\");\n          break;\n        case 50:\n          this.castSpell(\"regen\");\n          break;\n        case 51:\n          this.castSpell(\"aoeHeal\");\n          break;\n        case 52:\n          this.castSpell(\"aoeRegen\");\n          break;\n        case 53:\n          this.castSpell(\"impactHeal\");\n          break;\n        case 54:\n          this.castSpell(\"revive\");\n          break;\n        case 48:\n          this.castSpell(\"win\");\n          break;\n      }\n    });\n  }\n\n  castSpell(spell){\n    let selected;\n    this.spells = new Spells({ game: this });\n    \n    switch (spell) {\n      case \"cure\":\n        selected = this.findSelected();\n        if (!this.activeGCD && selected) {\n          this.spells.cure(selected);\n        } else if (selected === false) {\n          this.errorCode = 3;\n        } else {\n          this.errorCode = 1;\n        }\n        break;\n      case \"regen\":\n        selected = this.findSelected();\n        if (!this.activeGCD && selected) {\n          this.spells.regen(selected);\n        } else if (selected === false) {\n          this.errorCode = 3;\n        } else {\n          this.errorCode = 1;\n        };\n        break;\n      case \"aoeHeal\":\n        if (!this.activeGCD) {\n          this.spells.aoeHeal();\n        } else {\n          this.errorCode = 1;\n        };\n        break;\n      case \"aoeRegen\":\n        if (!this.activeGCD) {\n          this.spells.aoeRegen();\n        } else {\n          this.errorCode = 1;\n        };\n        break;\n      case \"impactHeal\":\n        selected = this.findSelected();\n        if (this.impactCD === 0 && selected) {\n          this.spells.impactHeal(selected);\n        } else if (selected === false) {\n          this.errorCode = 3;\n        }\n        break;\n      case \"revive\":\n        selected = this.findSelected();\n        if (selected.currentHp === 0) {\n          this.spells.revive(selected);\n        } else if (selected === false) {\n          this.errorCode = 3;\n        };\n        break;\n      case \"kill\":\n        this.boss.currentHp = 1;\n        break;\n    }\n  }\n\n  addClickableSpells(ctx){\n    let canvas = document.getElementById('game-canvas');\n    const pos = Game.SPELL_ICON_POS;\n\n    let spell1 = new Path2D();\n    spell1.rect(...pos['spell1']);\n    ctx.fillStyle = \"rgba(0,0,0,0.001\";\n    ctx.fill(spell1);\n\n    let spell2 = new Path2D();\n    spell2.rect(...pos['spell2']);\n    ctx.fillStyle = \"rgba(0,0,0,0.001\";\n    ctx.fill(spell2);\n\n    let spell3 = new Path2D();\n    spell3.rect(...pos['spell3']);\n    ctx.fillStyle = \"rgba(0,0,0,0.001\";\n    ctx.fill(spell3);\n\n    let spell4 = new Path2D();\n    spell4.rect(...pos['spell4']);\n    ctx.fillStyle = \"rgba(0,0,0,0.001\";\n    ctx.fill(spell4);\n    \n    let spell5 = new Path2D();\n    spell5.rect(...pos['spell5']);\n    ctx.fillStyle = \"rgba(0,0,0,0.001\";\n    ctx.fill(spell5);\n    \n    let spell6 = new Path2D();\n    spell6.rect(...pos['spell6']);\n    ctx.fillStyle = \"rgba(0,0,0,0.001\";\n    ctx.fill(spell6);\n\n    canvas.addEventListener('click', (e) => {\n        const rect = canvas.getBoundingClientRect();\n        if (ctx.isPointInPath(spell1, (e.clientX - rect.x), (e.clientY - rect.y))) {\n          this.castSpell(\"cure\");\n        };\n        if (ctx.isPointInPath(spell2, (e.clientX - rect.x), (e.clientY - rect.y))) {\n          this.castSpell(\"regen\");\n        };\n        if (ctx.isPointInPath(spell3, (e.clientX - rect.x), (e.clientY - rect.y))) {\n          this.castSpell(\"aoeHeal\");\n        };\n        if (ctx.isPointInPath(spell4, (e.clientX - rect.x), (e.clientY - rect.y))) {\n          this.castSpell(\"aoeRegen\");\n        };\n        if (ctx.isPointInPath(spell5, (e.clientX - rect.x), (e.clientY - rect.y))) {\n          this.castSpell(\"impactHeal\");\n        };\n        if (ctx.isPointInPath(spell6, (e.clientX - rect.x), (e.clientY - rect.y))) {\n          this.castSpell(\"revive\");\n        };\n    });\n  }\n\n  drawHovered(ctx){\n    switch (this.hovered) {\n      case \"cure\":\n        ctx.fillStyle = '#FFFFFF';\n        ctx.font = '16px sans-serif';\n        ctx.textAlign = \"center\";\n        ctx.fillText(\"Cure\", 71, 500);\n        break;\n      case \"regen\":\n        ctx.fillStyle = '#FFFFFF';\n        ctx.font = '16px sans-serif';\n        ctx.textAlign = \"center\";\n        ctx.fillText(\"Regen\", 154, 500);\n        break;\n      case \"aoeHeal\":\n        ctx.fillStyle = '#FFFFFF';\n        ctx.font = '16px sans-serif';\n        ctx.textAlign = \"center\";\n        ctx.fillText(\"Aoe Heal\", 237, 500);\n        break;\n      case \"aoeRegen\":\n        ctx.fillStyle = '#FFFFFF';\n        ctx.font = '16px sans-serif';\n        ctx.textAlign = \"center\";\n        ctx.fillText(\"Aoe Regen\", 320, 500);\n        break;\n      case \"impactHeal\":\n        ctx.fillStyle = '#FFFFFF';\n        ctx.font = '16px sans-serif';\n        ctx.textAlign = \"center\";\n        ctx.fillText(\"Impact Heal\", 403, 500);\n        break;\n      case \"revive\":\n        ctx.fillStyle = '#FFFFFF';\n        ctx.font = '16px sans-serif';\n        ctx.textAlign = \"center\";\n        ctx.fillText(\"Revive\", 486, 500);\n        break;\n      default:\n        break;\n    }\n  }\n\n  addSpellHover(ctx){\n    let canvas = document.getElementById('game-canvas');\n    const pos = Game.SPELL_ICON_POS;\n\n    let spell1 = new Path2D();\n    spell1.rect(...pos['spell1']);\n    ctx.fillStyle = \"rgba(0,0,0,0.001\";\n    ctx.fill(spell1);\n\n    let spell2 = new Path2D();\n    spell2.rect(...pos['spell2']);\n    ctx.fillStyle = \"rgba(0,0,0,0.001\";\n    ctx.fill(spell2);\n\n    let spell3 = new Path2D();\n    spell3.rect(...pos['spell3']);\n    ctx.fillStyle = \"rgba(0,0,0,0.001\";\n    ctx.fill(spell3);\n\n    let spell4 = new Path2D();\n    spell4.rect(...pos['spell4']);\n    ctx.fillStyle = \"rgba(0,0,0,0.001\";\n    ctx.fill(spell4);\n\n    let spell5 = new Path2D();\n    spell5.rect(...pos['spell5']);\n    ctx.fillStyle = \"rgba(0,0,0,0.001\";\n    ctx.fill(spell5);\n\n    let spell6 = new Path2D();\n    spell6.rect(...pos['spell6']);\n    ctx.fillStyle = \"rgba(0,0,0,0.001\";\n    ctx.fill(spell6);\n\n    canvas.onmousemove = (e) => {\n      const rect = canvas.getBoundingClientRect();\n      if (ctx.isPointInPath(spell1, (e.clientX - rect.x), (e.clientY - rect.y))) {\n        this.hovered = \"cure\";\n      };\n      if (ctx.isPointInPath(spell2, (e.clientX - rect.x), (e.clientY - rect.y))) {\n        this.hovered = \"regen\";\n      };\n      if (ctx.isPointInPath(spell3, (e.clientX - rect.x), (e.clientY - rect.y))) {\n        this.hovered = \"aoeHeal\";\n      };\n      if (ctx.isPointInPath(spell4, (e.clientX - rect.x), (e.clientY - rect.y))) {\n        this.hovered = \"aoeRegen\";\n      };\n      if (ctx.isPointInPath(spell5, (e.clientX - rect.x), (e.clientY - rect.y))) {\n        this.hovered = \"impactHeal\";\n      };\n      if (ctx.isPointInPath(spell6, (e.clientX - rect.x), (e.clientY - rect.y))) {\n        this.hovered = \"revive\";\n      };\n    };\n  }\n\n  drawPlayerBox(ctx){\n    ctx.clearRect(0, 0, Game.DIM_X, Game.DIM_Y);\n    ctx.fillStyle = '#CCCCCC';\n    ctx.fillRect(0, 0, Game.DIM_X, Game.DIM_Y);\n\n    ctx.fillStyle = \"#99ccff\";\n    ctx.beginPath();\n    ctx.rect(40, 40, 475, 375);\n    ctx.fill();\n  }\n\n  animateGCD(ctx){\n    // plan to rework this to use a secondary image with a transform.\n    if (this.activeGCD) {\n      this.gcdRemaining = this.gcdRemaining - Game.SPEED;\n      if (this.gcdRemaining <= 0){\n        this.activeGCD = false;\n        this.gcdRemaining = this.gcdTime;\n      }\n      // 1800/ 63 = x / crr time \n      const gcdHeight = Math.floor((this.gcdRemaining / this.gcdTime) * 63);\n      \n      // spell 1\n      ctx.fillStyle = 'rgba(0,0,0,0.5)';\n      ctx.beginPath();\n      ctx.rect(40, 502, 63, gcdHeight);\n      ctx.fill();\n\n      // spell 2\n      ctx.beginPath();\n      ctx.rect(123, 502, 63, gcdHeight);\n      ctx.fill();\n\n      // spell 3\n      ctx.beginPath();\n      ctx.rect(206, 502, 63, gcdHeight);\n      ctx.fill();\n\n      // spell 4\n      ctx.beginPath();\n      ctx.rect(289, 502, 63, gcdHeight);\n      ctx.fill();\n\n      // spell 5\n      // currently spell 5 is a \"off global cooldown\" skill and does not share //\n      // the global cooldown with other skills\n      // ctx.beginPath();\n      // ctx.rect(372, 502, 63, gcdHeight);\n      // ctx.fill();\n\n      // spell 6\n      ctx.beginPath();\n      ctx.rect(455, 502, 63, gcdHeight);\n      ctx.fill();\n    }\n  }\n\n  animateSpellCD(ctx){\n    if (this.impactCD) {\n      this.impactCD = this.impactCD - Game.SPEED;\n      if (this.impactCD <= 0) {\n        this.impactCD = 0;\n      }\n    }\n      // 1800/ 63 = x / crr time \n    const impactCDHeight = Math.floor((this.impactCD / this.impactMaxCD) * 63);\n\n    ctx.fillStyle = 'rgba(0,0,0,0.5)';\n    ctx.beginPath();\n    ctx.rect(372, 502, 63, impactCDHeight);\n    ctx.fill();\n  }\n\n  drawPlayerSpells(ctx){\n    const pos = Game.SPELL_ICON_POS;\n\n    // spell 1\n    ctx.fillStyle = '#99ccff';\n    ctx.drawImage(\n      this.spellIcons.cureIcon, ...pos[\"spell1\"]\n    );\n\n    // spell 2\n    ctx.drawImage(\n      this.spellIcons.regenIcon, ...pos[\"spell2\"]\n    );\n\n    // spell 3\n    ctx.drawImage(\n      this.spellIcons.aoeHeal, ...pos[\"spell3\"]\n    );\n\n    // spell 4\n    ctx.drawImage(\n      this.spellIcons.aoeRegen, ...pos[\"spell4\"]\n    );\n\n    // spell 5\n    ctx.drawImage(\n      this.spellIcons.esuna, ...pos[\"spell5\"]\n    );\n\n    // spell 6\n    ctx.drawImage(\n      this.spellIcons.revive, ...pos[\"spell6\"]\n    );\n\n    //spell text\n    ctx.fillStyle = '#FFFFFF';\n    ctx.font = '16px sans-serif';\n    ctx.textAlign = \"center\";\n    ctx.fillText(\"1\", 71, 578);\n    ctx.fillText(\"2\", 154, 578);\n    ctx.fillText(\"3\", 237, 578);\n    ctx.fillText(\"4\", 320, 578);\n    ctx.fillText(\"5\", 403, 578);\n    ctx.fillText(\"6\", 486, 578);\n  }\n\n  drawMonsterBox(ctx){\n    // monster hp\n    ctx.fillStyle = '#cc0000';\n    ctx.beginPath();\n    ctx.rect(605, 55, 300, 26);\n    ctx.fill();\n  }\n\n  bossAttack() {\n    if (this.boss.timeSinceAttack < this.boss.attackRate && !this.boss.casting) {\n      this.boss.timeSinceAttack += Game.SPEED;\n    } else if (!this.boss.casting) {\n      this.boss.attackRandom();\n      this.boss.timeSinceAttack = 0;\n    }\n  }\n\n  makeBossSpells() {\n    const options = { game: this, boss: this.boss, party: this.party };\n    this.bossSpells = new BossSpells(options);\n  }\n\n  castBossSpell(spell) {\n    this.bossSpells[`${spell}`]();\n  }\n\n  bossCastBar(ctx){\n    if (this.boss.casting) {\n      let barLength = ((this.boss.currentCastTime / this.boss.castTime) * 300);\n      if (this.currentCastTime >= this.boss.castTime) {\n        this.boss.casting = false;\n        this.boss.currentCastTime = 0;\n        this.game.castTime = 0;\n      }\n      ctx.fillStyle = '#000000';\n      ctx.beginPath();\n      ctx.rect(605, 476, 300, 26);\n      ctx.fill();\n\n      ctx.fillStyle = '#9900cc';\n      ctx.beginPath();\n      ctx.rect(605, 476, barLength, 26);\n      ctx.fill();\n\n      ctx.fillStyle = '#FFFFFF';\n      ctx.font = \"18px Arial\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(this.boss.currentSpell, 755, 496);\n\n      this.boss.currentCastTime += Game.SPEED;\n    }\n  }\n\n  showErrors(ctx) {\n    if (this.errorCode !== 0) {\n      this.errorDisplay = new GameErrors(ctx, this.errorCode);\n      this.errorDisplay.draw();\n      setTimeout(\n        () => {\n          this.errorCode = 0;\n          this.errorDisplay = null;\n        }, 700);\n    };\n  };\n\n  playerAttack() {\n    this.party.forEach(member => {\n      if (member.timeSinceAttack < member.attackRate) {\n        member.timeSinceAttack += Game.SPEED;\n      } else {\n        member.attack(this.boss);\n        member.timeSinceAttack = 0;\n      }\n    });\n  }\n\n  checkBossHp() {\n    const currentHpPc = Math.floor(this.boss.currentHp / this.boss.maxHp * 100);\n    if (this.nextBossSpell === null) {\n      this.nextBossSpell = this.bossScript.shift();\n    }\n    \n    if (this.nextBossSpell && currentHpPc <= this.nextBossSpell.hp) {\n      this.castBossSpell(this.nextBossSpell.spell);\n      this.nextBossSpell = null;\n    }\n  }\n\n  regenMp() {\n    if (this.mpRegenTimer <= 0 && this.mp < 1000) {\n      this.mp += 5;\n      this.mpRegenTimer = 75;\n    } else {\n      this.mpRegenTimer -= 1;\n    }\n  }\n\n  draw(ctx){\n    // boss attacks\n    this.bossAttack();\n    this.playerAttack();\n    this.checkBossHp();\n\n    // npc bounding box\n    ctx.clearRect(0, 0, Game.DIM_X, Game.DIM_Y);\n    ctx.fillStyle = '#CCCCCC';\n    ctx.fillRect(0, 0, Game.DIM_X, Game.DIM_Y);\n    \n    // ctx.beginPath();\n    ctx.drawImage(this.bg, 0, 0, Game.DIM_X, Game.DIM_Y);\n\n    ctx.fillStyle = \"rgba(82, 82, 122, 0.5)\";\n    ctx.beginPath();\n    ctx.rect(40, 40, 475, 196);\n    ctx.fill();\n\n    // drawing player spell list\n    this.drawPlayerSpells(ctx);\n\n    //drawing monster box\n    this.drawMonsterBox(ctx);\n    this.boss.draw(ctx);\n\n    // rendering all npc frames\n    this.party.forEach(member => {\n      member.draw(ctx);\n      // this.showSelected();\n    });\n    this.playerCastBar(ctx);\n    this.manaBar(ctx);\n    this.healthBar(ctx)\n    this.animateGCD(ctx);\n    this.animateSpellCD(ctx);\n    this.bossCastBar(ctx);\n    this.deadPlayerCheck();\n    this.drawHovered(ctx);\n    this.showErrors(ctx);\n    this.regenMp();\n  }\n}\n\nGame.DIM_X = 1000;\nGame.DIM_Y = 600;\nGame.SPEED = 66;\n\n// locations on the battlefield of each character\n// positions will go tank(s) up closest to the boss\n// next will be dps\n// healer will be last\nGame.NPC_ICON_POS = [\n\n];\n\nGame.SPELL_ICON_POS = {\n  \"spell1\": [40, 502, 63, 63],\n  \"spell2\": [123, 502, 63, 63],\n  \"spell3\": [206, 502, 63, 63],\n  \"spell4\": [289, 502, 63, 63],\n  \"spell5\": [372, 502, 63, 63],\n  \"spell6\": [455, 502, 63, 63],\n}\n\nGame.NPC_POS = [\n  [57,60], [148, 60], [239,60], [330,60], [421,60],\n  [57,146], [148, 146], [239,146], [330,146], [421,146],\n  [57,252], [148, 252], [239,252], [330,252], [421,252],\n  [57,333], [148, 333], [239,333], [330,333], [421,333]\n];\n\nmodule.exports = Game;\n\n\n//# sourceURL=webpack:///./src/game.js?");

/***/ }),

/***/ "./src/game_view.js":
/*!**************************!*\
  !*** ./src/game_view.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Game = __webpack_require__(/*! ./game.js */ \"./src/game.js\");\n\nclass GameView {\n  constructor(ctx) {\n    this.ctx = ctx;\n\n    this.currentLevel = 0;\n\n    this.canvas = document.getElementById('game-canvas');\n    this.state = \"start\";\n\n    this.fps = 15;\n    this.fpsInterval = 1000/ this.fps;\n    this.startTime = Date.now();\n    this.then = Date.now();\n\n    // this will stop the request animation frames if at a static screen\n    this.playing = false;\n  }\n\n  animate(fps){\n    this.fpsInterval = 1000/fps;\n    this.then = Date.now();\n    this.startTime = this.then;\n    this.rootRender();\n  }\n\n  rootRender(){\n    // setTimeout(requestAnimationFrame(this.rootRender.bind(this)), 1000);\n    if (this.playing){\n      requestAnimationFrame(this.rootRender.bind(this));\n    }\n    this.now = Date.now();\n    let elapsed = this.now - this.then;\n\n    if (elapsed > this.fpsInterval){\n      this.then = this.now - (elapsed % this.fpsInterval);\n\n      if (this.game.gameOver && this.state === \"level1\") {\n        this.level1End();\n      } else if (this.game.gameOver) {\n        this.gameOverScreen();\n        this.state = \"gameover\";\n      } else if (this.game.gameOverBad) {\n        this.gameOverBad();\n        this.state = \"gameover\";\n      } else {\n        this.game.draw(this.ctx);\n      }\n\n    }\n  }\n\n  start(){\n    this.ctx.clearRect(0, 0, Game.DIM_X, Game.DIM_Y);\n    this.ctx.fillStyle = '#050505';\n    this.ctx.fillRect(0, 0, Game.DIM_X, Game.DIM_Y);\n\n    // ctx.beginPath();\n    // this.ctx.drawImage(this.bg, 0, 0, Game.DIM_X, Game.DIM_Y);\n\n    this.ctx.fillStyle = '#FFFFFF';\n    this.ctx.font = \"24px Arial\";\n    this.ctx.textAlign = \"center\";\n    this. ctx.fillText(\"Start MMO Healer\", Game.DIM_X/2, Game.DIM_Y/2);\n\n\n// start button event listener\n    const backing = new Path2D();\n    backing.rect(400, 278, 200, 26);\n    this.ctx.fillStyle = \"rgba(0,0,0,0.001\";\n    this.ctx.fill(backing);\n\n    this.canvas.addEventListener('click', (e) => {\n      if (this.state === \"start\"){\n        const rect = this.canvas.getBoundingClientRect();\n        if (this.ctx.isPointInPath(backing, (e.clientX - rect.x), (e.clientY - rect.y))) {\n\n          this.tutorial();\n        }\n      }\n    });\n  }\n\n  tutorial() {\n    this.state = \"tutorial\";\n    const splash = new Image(1,1);\n    splash.src = './assets/tutorial.jpg';\n\n    this.ctx.clearRect(0, 0, Game.DIM_X, Game.DIM_Y);\n    this.ctx.fillStyle = '#050505';\n    this.ctx.fillRect(0, 0, Game.DIM_X, Game.DIM_Y);\n\n    splash.onload = () => {\n      this.ctx.drawImage(splash, 0, 0, Game.DIM_X, Game.DIM_Y);\n    };\n      \n      const backing = new Path2D();\n      backing.rect(630, 320, 246, 56);\n      this.ctx.fillStyle = \"rgba(000,0,0,0.01)\";\n      this.ctx.fill(backing);\n    this.game = null;\n    this.canvas.addEventListener('click', (e) => {\n      if (this.state === \"tutorial\"){\n        const rect = this.canvas.getBoundingClientRect();\n        if (this.ctx.isPointInPath(backing, (e.clientX - rect.x), (e.clientY - rect.y))) {\n\n          this.level1();\n        }\n      }\n    });\n  }\n\n  level1(){\n    this.state = \"level1\";\n    this.game = null;\n    this.currentLevel = 1;\n    const bgm = document.getElementById(\"bgm\");\n    if (bgm){\n      bgm.parentNode.removeChild(bgm);\n    }\n\n    this.music();\n\n    let aoeRegen = new Image(1,1);\n      aoeRegen.src = \"./spellicons/assize.png\";\n    let esuna = new Image(1,1);\n      esuna.src = \"./spellicons/esuna.png\";\n    let revive = new Image(1,1);\n      revive.src = \"./spellicons/verraise.png\";\n    let cureIcon = new Image(1,1);\n      cureIcon.src = \"./spellicons/cure_ii.png\";\n    let regenIcon = new Image(1,1);\n      regenIcon.src = \"./spellicons/regen.png\";\n    let aoeHeal = new Image(1,1);\n      aoeHeal.src = \"./spellicons/helios.png\";\n    const boss = new Image(1,1);\n      boss.src = \"./assets/Bahamutff6.png\";\n    const dead = new Image(1,1);\n      dead.src = \"./assets/skull.png\";\n    const bg = new Image(1,1);\n      bg.src = \"./assets/dungeonbg1.jpg\";\n    const statusIcon = new Image(1,1);\n      statusIcon.src = \"./spellicons/status.png\";\n\n    const canvasEl = document.getElementById('game-canvas');\n    const ctx = canvasEl.getContext(\"2d\");\n  \n\n    const spellIcons = { cureIcon, regenIcon, aoeHeal, aoeRegen, esuna, revive };\n    \n    const bossScript = [\n      {spell: \"flare\", hp: 99},\n      {spell: \"flare\", hp: 95}, \n      {spell: \"lifeShaver\", hp: 85},\n      {spell: \"flare\", hp: 75},\n      {spell: \"lifeShaver\", hp: 65},\n      {spell: \"flare\", hp: 50},\n      {spell: \"lifeShaver\", hp: 45},\n      {spell: \"ahkmorn\", hp: 20},\n      {spell: \"ahkmorn\", hp: 1}\n    ];\n\n\n      const options = {\n      comp: { tank: 1, healer: 1, dps: 3 },\n      ctx, canvas: canvasEl, bossSrc: boss,\n      dead, bg, spellIcons, level: this.state, bossScript, statusIcon\n    };\n\n\n    this.game = new Game(options);\n    this.playing = true;\n    this.rootRender();\n  }\n\n  level2(){\n    this.state = \"level2\";\n    this.game = null;\n    this.currentLevel = 2;\n    this.music();\n\n    let aoeRegen = new Image(1, 1);\n    aoeRegen.src = \"./spellicons/assize.png\";\n    let esuna = new Image(1, 1);\n    esuna.src = \"./spellicons/esuna.png\";\n    let revive = new Image(1, 1);\n    revive.src = \"./spellicons/verraise.png\";\n    let cureIcon = new Image(1, 1);\n    cureIcon.src = \"./spellicons/cure_ii.png\";\n    let regenIcon = new Image(1, 1);\n    regenIcon.src = \"./spellicons/regen.png\";\n    let aoeHeal = new Image(1, 1);\n    aoeHeal.src = \"./spellicons/helios.png\";\n    const boss = new Image(1, 1);\n    boss.src = \"./assets/virtue.png\";\n    const dead = new Image(1, 1);\n    dead.src = \"./assets/skull.png\";\n    const bg = new Image(1, 1);\n    bg.src = \"./assets/stars.jpg\";\n    const statusIcon = new Image(1, 1);\n    statusIcon.src = \"./spellicons/status.png\";\n\n    const canvasEl = document.getElementById('game-canvas');\n    const ctx = canvasEl.getContext(\"2d\");\n\n    const spellIcons = { cureIcon, regenIcon, aoeHeal, aoeRegen, esuna, revive };\n\n    const bossScript = [\n      { spell: \"holy\", hp: 99 },\n      { spell: \"dualCast\", hp: 95 },\n      { spell: \"breakWeapon\", hp: 85 },\n      { spell: \"bio\", hp: 80 },\n      { spell: \"meteor\", hp: 75 },\n      { spell: \"bio\", hp: 70 },\n      { spell: \"lifeShaver\", hp: 65 },\n      { spell: \"dualCast\", hp: 50 },\n      { spell: \"bio\", hp: 40 },\n      { spell: \"lifeShaver\", hp: 35 },\n      { spell: \"meteor\", hp: 20 },\n      { spell: \"dualCast\", hp: 20 },\n      { spell: \"apocalypse\", hp: 2 }\n    ];\n\n\n    const options = {\n      comp: { tank: 2, healer: 1, dps: 7 },\n      ctx, canvas: canvasEl, bossSrc: boss,\n      dead, bg, spellIcons, level: this.state, bossScript, statusIcon\n    };\n\n\n    this.game = new Game(options);\n    this.playing = true;\n    this.rootRender();\n  }\n\n  music(){\n    let promise;\n    switch (this.currentLevel) {\n      case 1:\n        if (!document.getElementById('bgm')) {\n          this.addBGM(\"./assets/ultima.mp3\");\n        } else {\n          this.changeBGM(\"./assets/ultima.mp3\");\n        }\n        const bgm = document.getElementById(\"bgm\");\n        bgm.currentTime = 60.5;\n        promise = bgm.play();\n        if (promise){\n          promise.catch(() => {});\n        }\n        bgm.volume = 0.4;\n        break;\n      case 2:\n        this.changeBGM('./assets/Answers.mp3');\n        promise = document.getElementById('bgm').play();\n        if (promise) {\n          promise.catch(() => {});\n        }\n        break;\n      default:\n        break;\n    }\n  }\n\n  addBGM(src){\n    let bg = document.createElement(\"audio\");\n    bg.src=src;\n    bg.id=\"bgm\";\n    bg.loop = true;\n    document.getElementById('music').appendChild(bg);\n\n    let node = document.createElement(\"img\");\n    node.src=\"./assets/Speaker_Icon.png\";\n    node.id = \"speaker\";\n    node.addEventListener('click', this.togglePause);\n\n    document.getElementById('canvas').appendChild(node);\n  }\n\n  changeBGM(src){\n    let bgm = document.getElementById('bgm');\n    if (bgm.playing){\n      bgm.pause();\n    }\n    bgm.src=src;\n    bgm.currentTime = 0;\n    bgm.loop = true;\n    bgm.load();\n  }\n\n  togglePause() {\n    // console.log(\"YO YOU WANNA PAUSE STUFF\");\n    const bgm = document.getElementById(\"bgm\");\n    const img = document.getElementById(\"speaker\");\n\n    bgm.paused ? bgm.play() : bgm.pause();\n    \n    return bgm.paused ? img.src = \"./assets/mute_icon.png\" : img.src = \"./assets/Speaker_Icon.png\";\n    \n  }\n\n  gameOverBad() {\n    // event listener to restart the game\n    this.ctx.clearRect(0, 0, Game.DIM_X, Game.DIM_Y);\n    this.ctx.fillStyle = '#000000';\n    this.ctx.fillRect(0, 0, Game.DIM_X, Game.DIM_Y);\n\n    const eb = new Path2D();\n    eb.rect(440, 369, 120, 2);\n    this.ctx.fillStyle = \"rgba(255,255,255,1)\";\n    this.ctx.fill(eb);\n\n    this.ctx.fillStyle = 'FFFFFF';\n    this.ctx.font = \"24px Arial\";\n    this.ctx.textAlign = \"center\";\n    this.ctx.fillText(\"You Died...\", Game.DIM_X / 2, Game.DIM_Y / 2);\n    this.ctx.fillText(\"Play again?\", 500, 360);\n\n\n    const backing = new Path2D();\n    backing.rect(430, 340, 150, 26);\n    this.ctx.fillStyle = \"rgba(0,0,0,0.05)\";\n    this.ctx.fill(backing);\n\n\n    this.canvas.addEventListener('click', (e) => {\n      const rect = this.canvas.getBoundingClientRect();\n      if (this.ctx.isPointInPath(backing, (e.clientX - rect.x), (e.clientY - rect.y))) {\n\n        this.level1();\n      }\n    });\n    // end event listener\n\n    this.playing = false;\n  }\n\n  level1End() {\n    // gameover screen\n\n    this.ctx.clearRect(0, 0, Game.DIM_X, Game.DIM_Y);\n    this.ctx.fillStyle = '#000000';\n    this.ctx.fillRect(0, 0, Game.DIM_X, Game.DIM_Y);\n\n    let overhealVal = Math.floor((this.game.overheal / this.game.healed) * 100);\n    if (isNaN(overhealVal)) {\n      overhealVal = 0;\n    }\n    const overhealText = \"Overheal percentage %\" + overhealVal;\n    const deathCountText = \"Death count: \" + this.game.deathCount;\n    const totalHealed = \"Total Healed: \" + this.game.healed + \" hp\";\n    const eb = new Path2D();\n    eb.rect(440, (Game.DIM_Y / 2) + 93, 120, 2);\n    this.ctx.fillStyle = \"rgba(255,255,255,1)\";\n    this.ctx.fill(eb);\n\n    this.ctx.fillStyle = 'FFFFFF';\n    this.ctx.font = \"24px Arial\";\n    this.ctx.textAlign = \"center\";\n    this.ctx.fillText(overhealText, Game.DIM_X / 2, Game.DIM_Y / 2);\n    this.ctx.fillText(totalHealed, Game.DIM_X / 2, (Game.DIM_Y / 2) + 30);\n    this.ctx.fillText(deathCountText, Game.DIM_X / 2, (Game.DIM_Y / 2) + 60);\n    this.ctx.fillText(\"Next Level\", Game.DIM_X / 2, (Game.DIM_Y / 2) + 90);\n\n    // event listener to restart the game\n    const backing = new Path2D();\n    backing.rect(430, 370, 150, 26);\n    this.ctx.fillStyle = \"rgba(0,0,0,0.05)\";\n    this.ctx.fill(backing);\n\n    this.canvas.addEventListener('click', (e) => {\n      const rect = this.canvas.getBoundingClientRect();\n      if (this.ctx.isPointInPath(backing, (e.clientX - rect.x), (e.clientY - rect.y))) {\n\n        this.level2();\n      }\n    });\n    // end event listener\n\n    this.playing = false;\n  }\n\n  gameOverScreen() {\n    // gameover screen\n\n    this.ctx.clearRect(0, 0, Game.DIM_X, Game.DIM_Y);\n    this.ctx.fillStyle = '#000000';\n    this.ctx.fillRect(0, 0, Game.DIM_X, Game.DIM_Y);\n\n    let overhealVal = Math.floor((this.game.overheal / this.game.healed) * 100);\n    if (isNaN(overhealVal)) {\n      overhealVal = 0;\n    }\n    const overhealText = \"Overheal percentage %\" + overhealVal;\n    const deathCountText = \"Death count: \" + this.game.deathCount;\n    const totalHealed = \"Total Healed: \" + this.game.healed + \" hp\";\n    const eb = new Path2D();\n    eb.rect(438, (Game.DIM_Y / 2) + 93, 120, 2);\n    this.ctx.fillStyle = \"rgba(255,255,255,1)\";\n    this.ctx.fill(eb);\n\n    this.ctx.fillStyle = 'FFFFFF';\n    this.ctx.font = \"24px Arial\";\n    this.ctx.textAlign = \"center\";\n    this.ctx.fillText(overhealText, Game.DIM_X / 2, Game.DIM_Y / 2);\n    this.ctx.fillText(totalHealed, Game.DIM_X / 2, (Game.DIM_Y / 2) + 30);\n    this.ctx.fillText(deathCountText, Game.DIM_X / 2, (Game.DIM_Y / 2) + 60);\n    this.ctx.fillText(\"Play again?\", Game.DIM_X / 2, (Game.DIM_Y / 2) + 90);\n\n    // event listener to restart the game\n    const backing = new Path2D();\n    backing.rect(430, 370, 150, 26);\n    this.ctx.fillStyle = \"rgba(0,0,0,0.05)\";\n    this.ctx.fill(backing);\n\n    this.canvas.addEventListener('click', (e) => {\n      const rect = this.canvas.getBoundingClientRect();\n      if (this.ctx.isPointInPath(backing, (e.clientX - rect.x), (e.clientY - rect.y))) {\n        this.level1();\n      }\n    });\n    // end event listener\n    this.playing = false;\n  }\n}\n\n\n\nmodule.exports = GameView;\n\n//# sourceURL=webpack:///./src/game_view.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Game = __webpack_require__(/*! ./game.js */ \"./src/game.js\");\nconst GameView = __webpack_require__(/*! ./game_view.js */ \"./src/game_view.js\");\n\n\n\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  //this allows for a rounded rectangle to be drawn, is needed for the bars\n  // use it like: \n  // ctx.roundRect(5, 5, 100, 100, {upperLeft: 25, upperRight: 25, lowerRight: 50, LowerLeft 75}, true, false);\n  // this will draw a rounded rectangle with a fill and no outline\n  CanvasRenderingContext2D.prototype.roundRect = function (x, y, width, height, radius, fill, stroke) {\n      var cornerRadius = { upperLeft: 0, upperRight: 0, lowerLeft: 0, lowerRight: 0 };\n      if (typeof stroke == \"undefined\") {\n          stroke = true;\n      }\n      if (typeof radius === \"object\") {\n          for (var side in radius) {\n              cornerRadius[side] = radius[side];\n          }\n      }\n\n      this.beginPath();\n      this.moveTo(x + cornerRadius.upperLeft, y);\n      this.lineTo(x + width - cornerRadius.upperRight, y);\n      this.quadraticCurveTo(x + width, y, x + width, y + cornerRadius.upperRight);\n      this.lineTo(x + width, y + height - cornerRadius.lowerRight);\n      this.quadraticCurveTo(x + width, y + height, x + width - cornerRadius.lowerRight, y + height);\n      this.lineTo(x + cornerRadius.lowerLeft, y + height);\n      this.quadraticCurveTo(x, y + height, x, y + height - cornerRadius.lowerLeft);\n      this.lineTo(x, y + cornerRadius.upperLeft);\n      this.quadraticCurveTo(x, y, x + cornerRadius.upperLeft, y);\n      this.closePath();\n      if (stroke) {\n          this.stroke();\n      }\n      if (fill) {\n          this.fill();\n      }\n  } \n\n  const canvasEl = document.getElementById('game-canvas');\n  const ctx = canvasEl.getContext(\"2d\");\n  canvasEl.width = Game.DIM_X;\n  canvasEl.height = Game.DIM_Y;\n\n  new GameView(ctx).start();\n});\n\n// const options = { maxHp: 200, attackRate: 1800, attackValue: 4, color: \"#003399\", pos: [40,40]}\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/npc.js":
/*!********************!*\
  !*** ./src/npc.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Tank = __webpack_require__(/*! ./units/tank.js */ \"./src/units/tank.js\");\nconst Spells = __webpack_require__(/*! ./spells.js */ \"./src/spells.js\");\nconst Game = __webpack_require__(/*! ./game.js */ \"./src/game.js\");\n\nclass NPC {\n  constructor(options){\n    this.maxHp = options.maxHp;\n    this.currentHp = options.maxHp;\n    this.attackRate = options.attackRate || 1500;\n    this.timeSinceAttack = 0;\n    this.attackValue = options.attackValue;\n    this.color = options.color || \"#CC22CC\";\n    this.pos = options.pos;\n    this.buffs = [];\n    this.debuffs = [];\n    this.selected = false;\n    this.game = options.game;\n    this.ctx = options.ctx;\n    this.canvas = options.canvas;\n    this.statusIcon = options.statusIcon;\n    this.baseAttack = options.attackValue;\n    this.toggleClickable();\n    this.speed = options.speed;\n    this.npcIcon = options.npcIcon;\n  }\n\n  toggleClickable() {\n    const boundSelector = this.selector.bind(this);\n    if (!this.game.gameover) {\n      this.canvas.addEventListener('click', boundSelector);\n    } else {\n      this.canvas.removeEventListener('click', boundSelector);\n    }\n  }\n\n  selector(e){\n    const backing = new Path2D();\n    backing.rect(this.pos[0], this.pos[1], 76, 66);\n    this.ctx.fillStyle = \"rgba(0,0,0,0.01)\";\n    this.ctx.fill(backing);\n\n    const rect = this.canvas.getBoundingClientRect();\n    if (this.ctx.isPointInPath(backing, (e.clientX - rect.x), (e.clientY - rect.y))) {\n      this.game.clearSelected();\n      this.selected = true;\n    }\n  }\n\n  attack(target){\n    if (target.currentHp > 0 && this.currentHp > 0){\n      target.currentHp = target.currentHp - this.attackValue;\n    }\n    if (target.currentHp < 0){\n      if (target !== this.game.boss) {\n        this.game.deathCount += 1;\n      }\n      target.currentHp = 0;\n    }\n  }\n\n  receiveDamage(amount){\n    this.currentHp = this.currentHp - amount;\n  }\n\n  isDead(){\n    if (this.currentHp <= 0){\n      if (this.buffs.length > 0){\n        this.buffs = [];\n      }\n      return true;\n    }\n    return false;\n  }\n\n  draw(ctx) {\n    ctx.fillStyle = this.color;\n    ctx.beginPath();\n\n    if (this.isDead()){\n      ctx.lineWidth = 2;\n      ctx.strokeStyle = \"black\";\n      ctx.strokeRect(this.pos[0], this.pos[1], 76, 66);\n\n      ctx.rect(\n        this.pos[0],\n        this.pos[1],\n        76, 66\n      );\n      ctx.fill();\n      ctx.save();\n\n      ctx.restore();\n\n      ctx.drawImage(\n        this.game.dead,\n        this.pos[0] + 17,\n        this.pos[1] + 2,\n        42,\n        43.5\n      );\n    } else {\n      ctx.lineWidth = 2;\n      ctx.strokeStyle = \"white\";\n      ctx.strokeRect(this.pos[0], this.pos[1], 76, 66);\n\n      ctx.rect(\n        this.pos[0],\n        this.pos[1],\n        76, 66\n        );\n        ctx.fill();\n      if (this.npcIcon) {\n        ctx.drawImage(this.npcIcon, this.pos[0] + 17, this.pos[1] + 2, 42, 42);\n      }\n      ctx.save();\n    }\n      if (this.selected){\n        ctx.lineWidth = 2;\n        ctx.strokeStyle = 'yellow';\n        ctx.strokeRect(this.pos[0], this.pos[1], 76, 66);\n\n      ctx.restore();\n\n    }\n    this.drawStatus(ctx);\n    this.drawMaxHP(ctx);\n    this.drawCurrentHp(ctx);\n    // 120 is hardcoded currently to the refresh rate\n    this.statusAction(this.speed);\n  }\n\n  drawStatus(ctx){\n    if (this.buffs.length > 0){\n      this.buffs.forEach(buff => {\n        switch (buff.type) {\n          case \"heal\":\n            //regen icon\n            ctx.drawImage(\n              this.statusIcon,\n              0,\n              0,\n              20, 20,\n              this.pos[0] + 5, this.pos[1] + 5,\n              20, 20\n            );\n            break;\n          case \"posion\":\n            // posion icon\n            ctx.drawImage(\n              this.statusIcon,\n              20,\n              0,\n              20, 20,\n              this.pos[0] + 28, this.pos[1] + 5,\n              20, 20\n            );\n            break;\n          case \"BreakWeapon\":\n            // x icon\n            ctx.drawImage(\n              this.statusIcon,\n              0,\n              20,\n              20, 20,\n              this.pos[0] + 51, this.pos[1] + 5,\n              20, 20\n            );\n            break;\n          default:\n            break;\n        }\n      });\n    }\n  }\n\n  statusAction(speed){\n    let removal = [];\n    if (this.buffs.length > 0) {\n      this.buffs.forEach(buff => {\n        if (!this.isDead()) {\n        if (buff.activation <= 500) {\n          buff.activation += speed;\n\n        } else {\n          this.executeBuff(buff);\n          buff.duration -= buff.activation;\n          buff.activation = 0;\n        }\n      } else {\n        buff.duration = 0;\n      }\n      });\n      removal = this.buffs.filter(buff => buff.duration <= 0);\n      this.remove(removal);\n    }\n  }\n\n  executeBuff(buff){\n    switch (buff.type){\n      case \"heal\":\n        if (this.currentHp < this.maxHp){\n          this.currentHp += buff.heal;\n        } else {\n          this.game.overheal += buff.heal;\n        }\n        if (this.currentHp > this.maxHp) {\n          this.currentHp = this.maxHp;\n        }\n        this.game.healed += buff.heal;\n        break;\n      case \"posion\":\n        if (this.currentHp <= this.maxHp && this.currentHp > 0) {\n          this.currentHp -= buff.dmg;\n        } \n        if (this.currentHp <= 0) {\n          this.currentHp = 0;\n          this.game.deathCount += 1;\n        }\n        break;\n      case \"BreakWeapon\":\n        if (this.currentHp > 0) {\n          this.attackValue = 0;\n        } \n        break;\n    }\n  }\n\n  drawMaxHP(ctx) {\n    const posX = this.pos[0] + 5;\n    const posY = this.pos[1] + 48; \n    ctx.fillStyle = \"#000000\";\n    \n    ctx.lineWidth = 2;\n    ctx.strokeStyle = \"black\";\n    ctx.strokeRect(posX, posY, 66, 10);\n    ctx.beginPath();\n    ctx.rect(\n      posX, posY, 66, 10\n    );\n\n    ctx.fill();\n  }\n\n  drawCurrentHp(ctx) {\n    const posX = this.pos[0] + 5;\n    const posY = this.pos[1] + 48;\n    ctx.fillStyle = '#cc0000';\n    const currentHpVal = Math.floor((this.currentHp / this.maxHp) * 66);\n\n    ctx.beginPath();\n    ctx.rect(\n      posX, posY, currentHpVal, 10\n    );\n    ctx.fill();\n  }\n\n  receiveBuff(buff){\n    // buffs should come in with a buff type\n    // buffs should come in with a duration\n    // buffs should come in with an activiation\n    const buffIdx = this.buffs.indexOf(buff);\n    const existing = this.buffs[buffIdx];\n\n    if (existing) {\n      existing.duration += buff.duration;\n    } else {\n      this.buffs.push(buff);\n    }\n  }\n\n  remove(buffs){\n    buffs.forEach(buff => {\n      if (buff.type == \"BreakWeapon\"){\n        this.attackValue = this.baseAttack;\n      }\n      this.buffs.splice(this.buffs.indexOf(buff), 1);\n    });\n  }\n\n  buffTime(){\n    if (this.buffs){\n      this.buffs.forEach(buff => {\n        buff.time = buff.time - 1;\n        if (buff.time <= 0) {\n          this.remove(buff);\n        }\n      });\n      \n    }\n  }\n}\n\nmodule.exports = NPC;\n\n\n//# sourceURL=webpack:///./src/npc.js?");

/***/ }),

/***/ "./src/spells.js":
/*!***********************!*\
  !*** ./src/spells.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("class Spells {\n  constructor(options){\n    this.game = options.game;\n  }\n\n  cure(target) {\n    // add cast time and animation\n    if (this.game.mp >= 10){\n      setTimeout(() => {\n        if (!target.isDead()){\n          target.currentHp += 20;\n          this.game.healed += 20;\n        }\n        if (target.currentHp > target.maxHp){\n          this.game.overheal += target.currentHp - target.maxHp;\n          target.currentHp = target.maxHp;\n        }\n        this.game.mp = this.game.mp - 10;\n      }, 1500);\n      this.game.activeGCD = true;\n      this.game.spellText = \"Cure\";\n      this.game.castTime = 0;\n      this.game.isCasting = true;\n      this.game.castTimeInitial = 1500;\n    } else {\n      this.game.errorCode = 2;\n    };\n  }\n\n  regen(target) {\n    const regen = { type: 'heal', heal: 5, duration: 15000, activation: 0 };\n    if (this.game.mp >= 15){\n      target.receiveBuff(regen);\n      this.game.mp -= 15;\n      this.game.activeGCD = true;\n    } else {\n      this.game.errorCode = 2;\n    };\n  }\n\n  aoeHeal() {\n    //no target needed\n    if (this.game.mp >= 30) {\n      setTimeout(() => {\n        this.game.party.forEach(member => {\n          if (!member.isDead()){\n            member.currentHp += 15;\n            this.game.healed += 15;\n          }\n          if (member.currentHp > member.maxHp) {\n            this.game.overheal += member.currentHp - member.maxHp;\n            member.currentHp = member.maxHp;\n          }\n        });\n        this.game.mp = this.game.mp - 30;\n      }, 1500);\n      this.game.activeGCD = true;\n      this.game.spellText = \"Aoe Heal\";\n      this.game.castTime = 0;\n      this.game.isCasting = true;\n      this.game.castTimeInitial = 1500;\n    } else {\n      this.game.errorCode = 2;\n    };\n  }\n\n  esuna(target) {\n    if (this.game.mp >= 10) {\n      setTimeout(() => {\n        if (!target.isDead()) {\n          target.debuffs.pop();\n        }\n        this.game.mp = this.game.mp - 10;\n      }, 1500);\n      this.game.activeGCD = true;\n      this.game.spellText = \"Esuna\";\n      this.game.castTime = 0;\n      this.game.isCasting = true;\n      this.game.castTimeInitial = 1500;\n    } else {\n      this.game.errorCode = 2;\n    };\n  }\n\n  aoeRegen() {\n    const regen = { type: 'heal', heal: 5, duration: 20000, activation: 0 };\n    if (this.game.mp >= 75) {\n      setTimeout(() => {\n        this.game.party.forEach(member => {\n          if (!member.isDead()) {\n            member.currentHp += 5;\n            this.game.healed += 5;\n            member.buffs.push(regen);\n          }\n          if (member.currentHp > member.maxHp) {\n            this.game.overheal += member.currentHp - member.maxHp;\n            member.currentHp = member.maxHp;\n          }\n        });\n        this.game.mp = this.game.mp - 75;\n      }, 1500);\n      this.game.activeGCD = true;\n      this.game.spellText = \"Aoe Regen\";\n      this.game.castTime = 0;\n      this.game.isCasting = true;\n      this.game.castTimeInitial = 1500;\n    } else {\n      this.game.errorCode = 2;\n    };\n  }\n\n  revive(target) {\n    if (this.game.mp >= 100 && target.isDead()) {\n      setTimeout(() => {\n        target.currentHp = Math.floor(target.maxHp * 0.35);\n        this.game.mp = this.game.mp - 100;\n      }, 3600);\n      this.game.activeGCD = true;\n      this.game.spellText = \"Revive\";\n      this.game.castTime = 0;\n      this.game.isCasting = true;\n      this.game.castTimeInitial = 3600;\n    } else {\n      this.game.errorCode = 2;\n    };\n  }\n\n  impactHeal(target) {\n    if (this.game.mp >= 5 && target.currentHp > 0) {\n      target.currentHp += Math.floor(target.maxHp * 0.35);\n      if (target.currentHp > target.maxHp) {\n        this.game.overheal += (target.currentHp - target.maxHp);\n        target.currentHp = target.maxHp;\n      }\n      this.game.mp = this.game.mp - 5;\n      this.game.impactCD = 20000;\n    } else if (target.currentHp <= 0 ) {\n      this.game.errorCode = 3;\n    } else {\n      this.game.errorCode = 2;\n    };\n  }\n}\n\nmodule.exports = Spells;\n\n//# sourceURL=webpack:///./src/spells.js?");

/***/ }),

/***/ "./src/units/boss.js":
/*!***************************!*\
  !*** ./src/units/boss.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const NPC = __webpack_require__(/*! ../npc.js */ \"./src/npc.js\");\n\nclass Boss extends NPC {\n  constructor(options){\n    options.attackRate = 1800;\n    options.attackValue = 15;\n    options.color = '#003399';\n    options.pos = options.pos;\n    super(options);\n    this.bossSrc = options.bossSrc;\n    this.casting = false;\n    this.castTime = 0;\n    this.currentCastTime = 0;\n    this.timeSinceAttack = 0;\n    this.currentSpell = null;\n  }\n\n  draw(ctx){\n    if (this.isDead()){\n      ctx.fillStyle = '#1d1d1d';\n    }\n    \n    ctx.beginPath();\n    ctx.drawImage(\n      this.bossSrc,\n      this.pos[0],\n      this.pos[1] + 10,\n      245,\n      326.5\n    );\n\n    this.drawMaxHP(ctx);\n    this.drawCurrentHp(ctx);\n  }\n\n  drawMaxHP(ctx) {\n    const posX = 605;\n    const posY = 55; \n    ctx.fillStyle = \"#000000\";\n    \n\n    ctx.beginPath();\n    ctx.rect(\n      posX, posY, 300, 26\n    );\n\n    ctx.fill();\n  }\n\n  drawCurrentHp(ctx) {\n    const posX = 605;\n    const posY = 55;\n    ctx.fillStyle = '#cc0000';\n    const currentHpVal = Math.floor((this.currentHp / this.maxHp) * 300);\n\n    if (this.currentHp <= 0){\n      setTimeout(() => { this.game.gameOver = true; }, 2000);\n    }\n\n    ctx.beginPath();\n    ctx.rect(\n      posX, posY, currentHpVal, 26\n    );\n    ctx.fill();\n  }\n\n  selectRandom() {\n    let weights = [];\n    this.game.party.forEach((member, idx) => {\n      for (let i = 0; i < member.weight; i++){\n        weights.push(idx);\n      }\n    });\n    const selectedIdx = Math.floor(Math.random() * weights.length);\n    return weights[selectedIdx];\n  }\n\n  attackRandom(){\n    let selectedTarget = this.selectRandom();\n    const alive = this.game.party.find(target => target.currentHp > 0);\n    if (this.game.party[selectedTarget].currentHp <= 0){\n      selectedTarget = this.game.party.indexOf(alive);\n    }\n    if (alive) {\n      this.attack(this.game.party[selectedTarget]);\n    }\n  }\n\n}\n\nmodule.exports = Boss;\n\n//# sourceURL=webpack:///./src/units/boss.js?");

/***/ }),

/***/ "./src/units/boss_spells.js":
/*!**********************************!*\
  !*** ./src/units/boss_spells.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("class BossSpells {\n  constructor(options){\n    this.target = options.target;\n    this.boss = options.boss;\n    this.game = options.game;\n    this.ahkCast = false;\n    this.ahkmornCount = 0;\n    this.delay = 500;\n    this.dualCount = 0;\n  }\n\n  flare() {\n    const { party } = this.game;\n    const randomDmg = (Math.random() * 5) + 20;\n    this.boss.currentSpell = \"Flare\";\n    this.boss.casting = true;\n    this.boss.castTime = BossSpells.FLARE;\n    this.boss.currentCastTime = 0;\n    setTimeout(() => {\n\n      party.forEach(member => {\n        if (member.currentHp > 0 && this.boss.currentHp > 0) {\n          member.currentHp = member.currentHp - randomDmg;\n        }\n        if (member.currentHp < 0) {\n          this.game.deathCount += 1;\n          member.currentHp = 0;\n        }\n      });\n      this.boss.casting = false;\n    }, BossSpells.FLARE);\n  }\n\n  lifeShaver() {\n    const { party } = this.game;\n    let tankCount = 0;\n    party.forEach(member => {\n      if (member.maxHp === 200){\n        tankCount += 1;\n      }\n    });\n    const random = Math.floor(Math.random() * tankCount);\n    let selectedTank = party[random];\n    // if (selectedTank.isDead()){\n    //   selectedTank = party.find(member => member.currentHp > 0);\n    // }\n\n    const heavyDmg = selectedTank.maxHp * 0.6;\n\n    this.boss.currentSpell = \"Life Shaver\";\n    this.boss.casting = true;\n    this.boss.castTime = BossSpells.LIFESHAVER;\n    this.boss.currentCastTime = 0;\n    setTimeout(() => {\n      if (selectedTank.currentHp > 0 && this.boss.currentHp > 0) {\n        selectedTank.currentHp -= heavyDmg;\n      }\n      if (selectedTank.currentHp < 0) {\n        this.game.deathCount += 1;\n        selectedTank.currentHp = 0;\n      }\n      this.boss.casting = false;\n    }, BossSpells.LIFESHAVER);\n  }\n\n  ahkmorn() {\n    const { party } = this.game;\n    const randomDmg = Math.floor(Math.random() * 5) + 15;\n    this.boss.currentSpell = \"Ahkmorn\";\n    this.boss.casting = true;\n    this.boss.castTime = BossSpells.AHKMORN;\n    this.boss.currentCastTime = 0;\n    setTimeout(() => {\n      party.forEach(member => {\n        if (member.currentHp > 0 && this.boss.currentHp > 0) {\n          member.currentHp = member.currentHp - randomDmg;\n        }\n        if (member.currentHp < 0) {\n          this.game.deathCount += 1;\n          member.currentHp = 0;\n        }\n      });\n      this.ahkmornCount = 0;\n      this.ahkmornFast();\n    }, BossSpells.AHKMORN);\n  }\n\n  bio() {\n    const { party } = this.game;\n    const randomIdx = Math.floor(Math.random()* party.length);\n    const randomMember = party[randomIdx];\n    const posion = { type: 'posion', dmg: 5, duration: 15000, activation: 0};\n    this.boss.currentSpell = \"Bio\";\n    this.boss.casting = true;\n    this.boss.castTime = BossSpells.BIO;\n    this.boss.currentCastTime = 0;\n    setTimeout(() => {\n      if (randomMember.currentHp > 0 && this.boss.currentHp > 0){\n        randomMember.currentHp -= 5;\n        randomMember.buffs.push(posion);\n      }\n      this.boss.casting = false;\n    }, BossSpells.BIO);\n  }\n\n  breakWeapon() {\n    const { party } = this.game;\n    const randomIdx = Math.floor(Math.random() * party.length);\n    const randomMember = party[randomIdx];\n    const breakWeapon = { type: 'BreakWeapon', dmg: 0, duration: 15000, activation: 0};\n    this.boss.currentSpell = \"Break Weapon\";\n    this.boss.casting = true;\n    this.boss.castTime = BossSpells.BREAKWEAPON;\n    this.boss.currentCastTime = 0;\n    setTimeout(() => {\n      if (randomMember.currentHp > 0 && this.boss.currentHp > 0) {\n        randomMember.buffs.push(breakWeapon);\n      }\n      this.boss.casting = false;\n    }, BossSpells.BREAKWEAPON);\n  }\n\n  ahkmornFast() {\n    const { party } = this.game;\n    const randomDmg = Math.floor(Math.random() * 5) + 20;\n\n    if (this.ahkmornCount < 6){\n      this.delay += (500 * this.ahkmornCount);\n      setTimeout(() => {\n        party.forEach(member => {\n          if (member.currentHp > 0 && this.boss.currentHp > 0) {\n            member.currentHp = member.currentHp - randomDmg;\n          }\n          if (member.currentHp < 0) {\n            this.game.deathCount += 1;\n            member.currentHp = 0;\n          }\n        });\n      }, this.delay);\n      this.ahkmornCount += 1;\n      this.ahkmornFast();\n    } else {\n      this.endCast();\n    }\n  }\n\n  holy() {\n    const { party } = this.game;\n    const holyDmg = 45;\n    const breakWeapon = { type: 'BreakWeapon', dmg: 0, duration: 15000, activation: 0 };\n    this.boss.currentSpell = \"Holy\";\n    this.boss.casting = true;\n    this.boss.castTime = BossSpells.HOLY;\n    this.boss.currentCastTime = 0;\n    setTimeout(() => {\n      party.forEach(member => {\n        if (member.currentHp > 0 && this.boss.currentHp > 0) {\n          member.currentHp = member.currentHp - holyDmg;\n          member.receiveBuff(breakWeapon);\n        }\n        if (member.currentHp < 0) {\n          this.game.deathCount += 1;\n          member.currentHp = 0;\n        }\n      });\n      this.endCast();\n    }, BossSpells.HOLY);\n  }\n\n  meteor(){\n    const { party } = this.game;\n    const randomDmg = Math.floor(Math.random() * 75) + 15;\n    this.boss.currentSpell = \"Meteor\";\n    this.boss.casting = true;\n    this.boss.castTime = BossSpells.METEOR;\n    this.boss.currentCastTime = 0;\n    setTimeout(() => {\n      party.forEach(member => {\n        if (member.currentHp > 0 && this.boss.currentHp > 0) {\n          member.currentHp = member.currentHp - randomDmg;\n        }\n        if (member.currentHp < 0) {\n          this.game.deathCount += 1;\n          member.currentHp = 0;\n        }\n      });\n      this.endCast();\n    }, BossSpells.METEOR);\n  }\n\n  apocalypse(){\n    const { party } = this.game;\n    const massiveDamage = 1000;\n    this.boss.currentSpell = \"Apocalypse\";\n    this.boss.casting = true;\n    this.boss.castTime = BossSpells.APOCALYPSE;\n    this.boss.currentCastTime = 0;\n    setTimeout(() => {\n      party.forEach(member => {\n        if (member.currentHp > 0 && this.boss.currentHp > 0) {\n          member.currentHp = member.currentHp - massiveDamage;\n        }\n        if (member.currentHp < 0) {\n          this.game.deathCount += 1;\n          member.currentHp = 0;\n        }\n      });\n      this.endCast();\n    }, BossSpells.APOCALYPSE);\n  }\n\n  dualCast() {\n    const spells = [\"Flare\", \"Bio II\", \"Holy\"];\n    const selectedSpell = spells[Math.floor(Math.random() * spells.length)];\n\n    this.boss.currentSpell = \"Dualcast \" + selectedSpell;\n    this.boss.casting = true;\n    this.boss.castTime = BossSpells.DUALCAST;\n    this.boss.currentCastTime = 0;\n    setTimeout(() => {\n      this.secondCast(selectedSpell);\n      this.endCast();\n    }, BossSpells.DUALCAST);\n  }\n\n  secondCast(spell){\n    const { party } = this.game;\n    const breakWeapon = { type: 'BreakWeapon', dmg: 0, duration: 15000, activation: 0 };\n    const posion = { type: 'posion', dmg: 5, duration: 15000, activation: 0 };\n\n    switch (spell) {\n      case \"Holy\":\n        party.forEach(member => {\n          if (member.currentHp > 0 && this.boss.currentHp > 0) {\n            member.currentHp = member.currentHp - 40;\n            member.receiveBuff(breakWeapon);\n          }\n          if (member.currentHp < 0) {\n            this.game.deathCount += 1;\n            member.currentHp = 0;\n          }\n        });\n        break;\n      case \"Bio II\":\n        party.forEach(member => {\n          if (member.currentHp > 0 && this.boss.currentHp > 0) {\n            member.receiveBuff(posion);\n          }\n        });\n        break;\n      case \"Flare\":\n        party.forEach(member => {\n          if (member.currentHp > 0 && this.boss.currentHp > 0) {\n            member.currentHp = member.currentHp - 25;\n          }\n          if (member.currentHp < 0) {\n            this.game.deathCount += 1;\n            member.currentHp = 0;\n          }\n        });\n        break;\n      default:\n        break;\n    }\n    if (this.dualCount === 0){\n      this.dualCount = 1;\n      setTimeout(() => this.secondCast(spell), 800);\n    } else {\n      this.dualCount = 0;\n    }\n  }\n\n  endCast() {\n    this.boss.casting = false;\n  }\n}\n\n\n\nBossSpells.FLARE = 2500;\nBossSpells.BIO = 1200;\nBossSpells.HOLY = 2800;\nBossSpells.BREAKWEAPON = 1800;\nBossSpells.LIFESHAVER = 2800;\nBossSpells.AHKMORN = 4500;\nBossSpells.METEOR = 3500;\nBossSpells.DUALCAST = 2800;\nBossSpells.APOCALYPSE = 9000;\n\nmodule.exports = BossSpells;\n\n\n//# sourceURL=webpack:///./src/units/boss_spells.js?");

/***/ }),

/***/ "./src/units/dps.js":
/*!**************************!*\
  !*** ./src/units/dps.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const NPC = __webpack_require__(/*! ../npc.js */ \"./src/npc.js\");\n\nclass Dps extends NPC {\n  constructor(options){\n\n    options.maxHp = 100;\n    options.attackRate = 1500;\n    options.attackValue = 8;\n    options.color = '#990000';\n    options.pos = options.pos;\n    super(options);\n\n    this.weight = this.calcWeight();\n  }\n\n  calcWeight(){\n    const nonTanks = this.game.comp.healer + this.game.comp.dps;\n\n    const weight = 30 / nonTanks;\n    return weight;\n  }\n}\n\nmodule.exports = Dps;\n\n//# sourceURL=webpack:///./src/units/dps.js?");

/***/ }),

/***/ "./src/units/healer.js":
/*!*****************************!*\
  !*** ./src/units/healer.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const NPC = __webpack_require__(/*! ../npc.js */ \"./src/npc.js\");\n\nclass Healer extends NPC {\n  constructor(options){\n\n    options.maxHp = 100;\n    options.attackRate = 1800;\n    options.attackValue = 0;\n    options.color = '#009933';\n    options.pos = options.pos;\n    super(options);\n    this.weight = this.calcWeight();\n  }\n\n  calcWeight(){\n    // tanks are statically weighted to 70%\n    // const numTanks = this.game.comp.tank;\n\n    // weighting the rest to be attacked 30% of the time\n    const nonTanks = this.game.comp.healer + this.game.comp.dps;\n\n    const weight = 30 / nonTanks;\n    return weight;\n  }\n}\n\nmodule.exports = Healer;\n\n//# sourceURL=webpack:///./src/units/healer.js?");

/***/ }),

/***/ "./src/units/tank.js":
/*!***************************!*\
  !*** ./src/units/tank.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const NPC = __webpack_require__(/*! ../npc.js */ \"./src/npc.js\");\n\nclass Tank extends NPC {\n  constructor(options){\n\n    options.maxHp = 200;\n    options.attackRate = 1800;\n    options.attackValue = 4;\n    options.color = '#003399';\n    options.pos = options.pos;\n    super(options);\n\n    this.weight = 70;\n  }\n}\n\nmodule.exports = Tank;\n\n//# sourceURL=webpack:///./src/units/tank.js?");

/***/ })

/******/ });